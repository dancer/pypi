import httpx


def check(name):
    r = httpx.get(f"https://pypi.org/pypi/{name}/json")
    return r.status_code == 404


names = [
    "agi",
    "bot",
    "gpt",
    "llm",
    "nlp",
    "nlu",
    "rag",
    "vqa",
    "ocr",
    "asr",
    "tts",
    "gan",
    "vae",
    "rnn",
    "cnn",
    "mlp",
    "fcn",
    "svm",
    "knn",
    "sgd",
    "ada",
    "opt",
    "rmw",
    "adagrad",
    "adamw",
    "adadelta",
    "neural",
    "neuron",
    "synapse",
    "cortex",
    "axon",
    "dendrite",
    "learn",
    "train",
    "test",
    "valid",
    "infer",
    "predict",
    "classify",
    "regress",
    "embed",
    "encode",
    "decode",
    "transform",
    "attend",
    "pool",
    "norm",
    "drop",
    "loss",
    "metric",
    "score",
    "eval",
    "bench",
    "measure",
    "gauge",
    "assess",
    "model",
    "param",
    "weight",
    "bias",
    "layer",
    "block",
    "module",
    "unit",
    "input",
    "output",
    "hidden",
    "feature",
    "logit",
    "prob",
    "dist",
    "sample",
    "batch",
    "epoch",
    "step",
    "iter",
    "grad",
    "delta",
    "update",
    "momentum",
    "tensor",
    "matrix",
    "vector",
    "scalar",
    "array",
    "shape",
    "dim",
    "axis",
    "token",
    "vocab",
    "corpus",
    "dataset",
    "sample",
    "label",
    "class",
    "target",
    "seq",
    "series",
    "sequence",
    "stream",
    "flow",
    "pipe",
    "chain",
    "graph",
    "node",
    "edge",
    "vertex",
    "leaf",
    "root",
    "branch",
    "tree",
    "forest",
    "deep",
    "wide",
    "dense",
    "sparse",
    "conv",
    "pool",
    "recur",
    "feedback",
    "forward",
    "backward",
    "backprop",
    "gradient",
    "jacobian",
    "hessian",
    "attention",
    "self",
    "cross",
    "multi",
    "head",
    "query",
    "key",
    "value",
    "context",
    "memory",
    "state",
    "hidden",
    "cell",
    "gate",
    "forget",
    "reset",
    "prompt",
    "instruct",
    "chat",
    "dialog",
    "converse",
    "respond",
    "reply",
    "generate",
    "create",
    "produce",
    "output",
    "emit",
    "yield",
    "make",
    "build",
    "parse",
    "analyze",
    "process",
    "handle",
    "manage",
    "control",
    "operate",
    "agent",
    "actor",
    "worker",
    "runner",
    "executor",
    "processor",
    "handler",
    "policy",
    "strategy",
    "plan",
    "goal",
    "objective",
    "reward",
    "value",
    "action",
    "move",
    "step",
    "turn",
    "play",
    "game",
    "env",
    "world",
    "observe",
    "perceive",
    "sense",
    "detect",
    "recognize",
    "identify",
    "spot",
    "reason",
    "think",
    "decide",
    "choose",
    "select",
    "pick",
    "opt",
    "prefer",
    "search",
    "explore",
    "exploit",
    "discover",
    "find",
    "seek",
    "hunt",
    "scan",
    "optimize",
    "improve",
    "enhance",
    "boost",
    "amplify",
    "maximize",
    "minimize",
    "cluster",
    "group",
    "segment",
    "partition",
    "divide",
    "split",
    "merge",
    "rank",
    "order",
    "sort",
    "arrange",
    "organize",
    "structure",
    "format",
    "filter",
    "select",
    "choose",
    "pick",
    "extract",
    "retrieve",
    "fetch",
    "map",
    "reduce",
    "fold",
    "scan",
    "apply",
    "transform",
    "convert",
    "cast",
    "stack",
    "queue",
    "heap",
    "list",
    "dict",
    "set",
    "tuple",
    "pair",
    "cache",
    "store",
    "save",
    "load",
    "read",
    "write",
    "dump",
    "restore",
    "sync",
    "async",
    "parallel",
    "concurrent",
    "thread",
    "process",
    "task",
    "lock",
    "mutex",
    "semaphore",
    "barrier",
    "event",
    "signal",
    "flag",
]

available = []
for name in names:
    status = "available" if check(name) else "taken"
    print(f"{name}: {status}")
    if status == "available":
        available.append(name)

with open("available.txt", "w") as f:
    for name in available:
        f.write(f"{name}\n")

print(f"\nfound {len(available)} available names")
print(f"saved to available.txt")
